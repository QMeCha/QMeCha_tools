#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import os
import numpy as np
import math
import time
import argparse
from itertools import product

'''
This script replaces the full Jastrow factor from a
dimer in equilibrium or in dissociation into the Jastrow
factor of its monomers. Replaces by default two-body cusps
(jc2), can also replace one-body cusps (jc1), two-body
dynamical Jastrow (jd2) and its associated basis set (jbas).
One-body dynamical Jastrow (jd1) not implemented.


REQUIRED INPUTS
jstFileIn:   Dimer jst.sav path
jstFileOut1: Monomer 1 jst.sav path
jstFileOut2: Monomer 2 jst.sav path

-id1:   List of indices associated with monomer 1.
-id2:   List of indices associated with monomer 2.
-param: Path to param.inp file generated by QMeCha.
-xyz:   Path to .xyz file generated for QMeCha.

OPTIONAL ARGUMENTS
-jc1:   Replace one-body cusps.
-jd2:   Replace two-body dynamical Jastrow.
-jbas:  Replace basis set parameters associated
        with two-body dynamical Jastrow.
        Takes additional arguments:
            jstBasIn:   Dimer frmbss.sav path
            jstBasOut1: Monomer 1 frmbss.sav path
            jstBasOut2: Monomer 2 frmbss.sav path
'''


p = argparse.ArgumentParser(
    prog="replaceDimerJast.py",
    description="Replaces the Jastrow factor from a dimer into its constituents. Two body cusps (jc2) are replaced always.",
    epilog="Replacing the one-body dynamical Jastrow not yet implemented. ",
)

p.add_argument("jstFileIn", help="Path of the source jst.sav file")
p.add_argument(
    "jstFileOut1", help="Path of the destination jst.sav file (first monomer)"
)
p.add_argument(
    "jstFileOut2", help="Path of the destination jst.sav file (second monomer)"
)

p.add_argument(
    "-id1",
    nargs="+",
    type=int,
    required=True,
    help="Indices of the first monomer, as they appear in the .xyz file.",
)
p.add_argument(
    "-id2",
    nargs="+",
    type=int,
    required=True,
    help="Indices of the second monomer, as they appear in the .xyz file.",
)
p.add_argument(
    "-param",
    type=str,
    required=True,
    help="Path to parameter file generated by QMeCha for the dimer.",
)
p.add_argument(
    "-xyz", type=str, required=True, help="Path to .xyz file generated by QMeCha for the dimer."
)

p.add_argument(
    "-jd2",
    action="store_true",
    help="(optional) Replace two-body dynamical Jastrow.",
)
p.add_argument(
    "-jc1", action="store_true", help="(optional) Replace one-body cusps."
)
p.add_argument(
    "-jbas",
    nargs=3,
    metavar=("jstBasIn", "jstBasOut1", "jstBasOut2"),
    help="(optional) Replace Jastrow basis set (input frmbass.sav path, monomer 1 frmbass.sav path, monomer 2 frmbass.sav path).",
)

p.add_argument(
    "--jtype",
    type=str,
    default='ma',
    help="(optional) Type of correlated Jastrow: [m (default), s, c][d, a, f]",
)

p.add_argument(
        "--reverse2b",
        action="store_true",
        help="(optional) Run the process in reverse by constructing the two-body dynamical Jastrow from the monomers and replacing it into the dimer."
)

def readJastFact(
    namejastFile: str,
    oneBodyCusp=None,
    twoBodyCusp=None,
    oneBodyDyn=None,
    twoBodyDyn=None,
):
    jastFileIn = open(namejastFile, "r")
    jastFileInLines = jastFileIn.readlines()
    jastFileIn.close()
    # One body Cusp
    if type(oneBodyCusp) == list:
        for line_num in range(len(jastFileInLines)):
            if "# One body Cusp parameters" in jastFileInLines[line_num]:
                break
        oneBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        line_num = line_num + 1
        oneBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        cmp_num = int(jastFileInLines[line_num].split()[2])
        if cmp_num > 0:
            for i in range(3 * cmp_num):
                line_num = line_num + 1
                oneBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        line_num = line_num + 1
        oneBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        cmp_num = int(jastFileInLines[line_num].split()[2])
        if cmp_num > 0:
            for i in range(3 * cmp_num):
                line_num = line_num + 1
                oneBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))

    # Two body Cusp
    if type(twoBodyCusp) == list:
        for line_num in range(len(jastFileInLines)):
            if "# Two body Cusp parameters" in jastFileInLines[line_num]:
                break
        twoBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        line_num = line_num + 1
        twoBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        cmp_num = int(jastFileInLines[line_num].split()[2])
        if cmp_num > 0:
            for i in range(3 * cmp_num):
                line_num = line_num + 1
                twoBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        line_num = line_num + 1
        twoBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        cmp_num = int(jastFileInLines[line_num].split()[2])
        if cmp_num > 0:
            for i in range(3 * cmp_num):
                line_num = line_num + 1
                twoBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        line_num = line_num + 1
        twoBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))
        cmp_num = int(jastFileInLines[line_num].split()[2])
        if cmp_num > 0:
            for i in range(3 * cmp_num):
                line_num = line_num + 1
                twoBodyCusp.append(jastFileInLines[line_num].replace("\n", ""))

    # One body Dynamical
    if type(oneBodyDyn) == list:
        for line_num in range(len(jastFileInLines)):
            if (
                "# Coefficients of the 1Body linear Jastrow"
                in jastFileInLines[line_num]
            ):
                break
        oneBodyDyn.append(jastFileInLines[line_num].replace("\n", ""))
        line_num = line_num + 1
        cmp_num = int(jastFileInLines[line_num].split()[0])
        oneBodyDyn.append(jastFileInLines[line_num].replace("\n", ""))
        if cmp_num > 0:
            for i in range(cmp_num):
                line_num = line_num + 1
                oneBodyDyn.append(jastFileInLines[line_num].replace("\n", ""))

    # Two body Dynamical
    if type(twoBodyDyn) == list:
        for line_num in range(len(jastFileInLines)):
            if (
                "# Coefficients of the 2Body linear Jastrow"
                in jastFileInLines[line_num]
            ):
                break
        twoBodyDyn.append(jastFileInLines[line_num].replace("\n", ""))
        line_num = line_num + 1
        cmp_num = int(jastFileInLines[line_num].split()[0])
        twoBodyDyn.append(jastFileInLines[line_num].replace("\n", ""))
        if cmp_num > 0:
            for i in range(cmp_num):
                line_num = line_num + 1
                twoBodyDyn.append(jastFileInLines[line_num].replace("\n", ""))


def writeJastFact(
    namejastFile: str,
    oneBodyCusp: list,
    twoBodyCusp: list,
    oneBodyDyn: list,
    twoBodyDyn: list,
):
    jastFilewr = open(namejastFile, "w")
    # One body Cusp
    for line_num in range(len(oneBodyCusp)):
        jastFilewr.write(str(oneBodyCusp[line_num]) + "\n")

    # Two body Cusp
    for line_num in range(len(twoBodyCusp)):
        jastFilewr.write(str(twoBodyCusp[line_num]) + "\n")

    # One body Dyn
    for line_num in range(len(oneBodyDyn)):
        jastFilewr.write(str(oneBodyDyn[line_num]) + "\n")

    # Two body Dyn
    for line_num in range(len(twoBodyDyn)):
        jastFilewr.write(str(twoBodyDyn[line_num]) + "\n")

    jastFilewr.close()


def calculateJastSize(jastform):
    jastsize = 0
    jast_orbitals = jastform.split("G")[:-1]
    orb_sizes = {"s": 1, "p": 3, "d": 5, "f": 7, "g": 9, "h": 11}
    for orb in jast_orbitals:
        orb_type = orb[1]
        jastsize += orb_sizes.get(orb_type, 0)
    return jastsize


def readJastBas(namejastFile: str, jastrowBasis: list):
    jastFileIn = open(namejastFile, "r")
    jastFileLines = jastFileIn.readlines()
    jastFileIn.close()
    read_next = True
    for i, line in enumerate(jastFileLines):
        if (i == 0):
            jastrowBasis.append(line)
            atomBasis = []
        elif read_next:
            bas_size = int(line.split()[1]) + int(line.split()[2])
            bas_read = 0
            if atomBasis != []:
                jastrowBasis.append(atomBasis)
            atomBasis = []
            atomBasis.append(line)
            read_next = False
        else:
            if line.split()[0] in ('S', 'P', 'D', 'F', 'G', 'H'):
                bas_read += 1
                l_read = 0
                l_size = int(line.split()[1])
            l_read += 1 if not line.split()[0] in ('S', 'P', 'D', 'F', 'G', 'H') else 0
            atomBasis.append(line)  # assumption is we use the same basis set
            read_next = bas_read == bas_size and l_read == l_size
    if atomBasis != []:
        jastrowBasis.append(atomBasis)


def writeJastBas(namejastFile: str, jastrowBasis: list, atom_indices: list):
    jastFileOut = open(namejastFile, "w")
    # Jastrow basis set coefficients
    jastFileOut.write(jastrowBasis[0])
    for a_idx in atom_indices:
        for line in jastrowBasis[a_idx]:
            jastFileOut.write(line)

    jastFileOut.close()


def readXyzFile(xyz_file_path):
    with open(xyz_file_path, 'r') as xyz_file:
        xyz_lines = xyz_file.readlines()
        n_atoms = int(xyz_lines[1].split()[-1])
        r_a = np.zeros(shape=(n_atoms, 3))
        a_type = ['']*n_atoms
        for i, line in enumerate(xyz_lines[6:6+n_atoms]):
            s_line = line.split()
            a_type[i] = "".join(filter(str.isalnum,s_line[0]))
            for k in range(1,4):
                r_a[i,k-1] = float(s_line[k])
    return a_type, np.array(r_a)


def readParamFile(paramFileName: str, jastSizes: list, atom_types: list):
    paramFile = open(paramFileName, "r")
    paramFileLines = paramFile.readlines()
    paramFile.close()
    for i, line in enumerate(paramFileLines):
        if line.split()[0] in atom_types:
            jastform = line.split()[-1]
            jastsize = calculateJastSize(jastform)
            for i, atom in enumerate(atom_types):
                if line.split()[0] == atom:
                    jastSizes[i] = jastsize


def replaceDynJast(
    twoBodyDynIn: list,
    twoBodyDynOut: list,
    jastSizes: list,
    atom_indices: list,
    jtype: str
):
    ends = np.cumsum(jastSizes)
    starts = ends - (np.array(jastSizes) - 1)
    jastSizes_partial = np.array(jastSizes)[np.array(atom_indices) - 1]
    ends_partial = np.cumsum(jastSizes_partial)
    starts_partial = ends_partial - (jastSizes_partial - 1)

    for i, line in enumerate(twoBodyDynIn):
        if jtype == 's' or jtype == 'c':
            if i in (0,1,2):
                twoBodyDynOut.append(line)
                continue
        elif jtype == 'm':
            if i in (0,1):
                twoBodyDynOut.append(line)
                continue
        else:
            print("Error! Jastrow type not recognized!")
            sys.exit(1)
        a1 = int(line.split()[0])
        a2 = int(line.split()[1])
        coeff = ' '.join(line.split()[2:])
        atom_id1 = np.argwhere(a1 <= ends)[0][0] + 1
        atom_id2 = np.argwhere(a2 <= ends)[0][0] + 1
        found = 1
        try:
            coeff_in_1 = np.argwhere(np.array(atom_indices) == atom_id1)[0][0]
            coeff_in_2 = np.argwhere(np.array(atom_indices) == atom_id2)[0][0]
        except:
            found = 0
            pass
        if found:
            a1_mod = starts_partial[coeff_in_1] + (a1 - starts[atom_id1 - 1])
            a2_mod = starts_partial[coeff_in_2] + (a2 - starts[atom_id2 - 1])
            newline = str(a1_mod) + " " + str(a2_mod) + " " + coeff
            twoBodyDynOut.append(newline)
    twoBodyDynOut[1] = " ".join(twoBodyDynOut[1].split()[1:])
    if jtype == 'm' or jtype == 'c':
        twoBodyDynOut[1] = str(len(twoBodyDynOut[2:])) + " " + twoBodyDynOut[1]
    elif jtype == 's':
        twoBodyDynOut[1] = str(len(twoBodyDynOut[2:])-1) + " " + twoBodyDynOut[1]

def replaceDynJast_inverse(
        twoBodyDynIn1: list,
        twoBodyDynIn2: list,
        twoBodyDynOut: list,
        jastSizes: list,
        atom_indices1: list,
        atom_indices2: list,
        jtype = str,
        is_full = bool
):
    max_idx = max(atom_indices1 + atom_indices2)
    atom_indices_full = np.arange(max_idx)

    ends = np.cumsum(jastSizes)
    starts = ends - (np.array(jastSizes) -1)


    jastSizes1 = np.array(jastSizes)[np.array(atom_indices1) -1]
    jastSizes2 = np.array(jastSizes)[np.array(atom_indices2) -1]
    ends1 = np.cumsum(jastSizes1)
    ends2 = np.cumsum(jastSizes2)
    starts1 = ends1 - jastSizes1 + 1
    starts2 = ends2 - jastSizes2 + 1

    for i, line in enumerate(twoBodyDynIn1):
        if jtype == 's' or jtype == 'c':
            if i in (0,1,2):
                twoBodyDynOut.append(line)
                sidx = 3
                continue
        elif jtype == 'm':
            if i in (0,1):
                twoBodyDynOut.append(line)
                sidx = 2
                continue
        else:
            print("Error! Jastrow type not recognized!")
            sys.exit(1)
        a1 = int(line.split()[0])
        a2 = int(line.split()[1])
        coeff = ' '.join(line.split()[2:])

        atom_id1_mon = np.argwhere(a1 <= ends1)[0][0] + 1
        atom_id2_mon = np.argwhere(a2 <= ends1)[0][0] + 1

        atom_id1_dim = atom_indices1[atom_id1_mon - 1]
        atom_id2_dim = atom_indices1[atom_id2_mon - 1]

        coeff_in_1 = atom_id1_mon - 1
        coeff_in_2 = atom_id2_mon - 1
        a1_mod = starts[atom_id1_dim -1] + (a1 - starts1[coeff_in_1])
        a2_mod = starts[atom_id2_dim -1] + (a2 - starts1[coeff_in_2])
        newline = str(a1_mod) + " " + str(a2_mod) + " " + coeff
        twoBodyDynOut.append(newline)

    for i, line in enumerate(twoBodyDynIn2[sidx:]):
        a1 = int(line.split()[0])
        a2 = int(line.split()[1])
        coeff = ' '.join(line.split()[2:])
        coeff_len = len(line.split()[2:])

        atom_id1_mon = np.argwhere(a1 <= ends2)[0][0] + 1
        atom_id2_mon = np.argwhere(a2 <= ends2)[0][0] + 1

        atom_id1_dim = atom_indices2[atom_id1_mon - 1]
        atom_id2_dim = atom_indices2[atom_id2_mon - 1]

        coeff_in_1 = atom_id1_mon - 1
        coeff_in_2 = atom_id2_mon - 1

        a1_mod = starts[atom_id1_dim -1] + (a1 - starts2[coeff_in_1])
        a2_mod = starts[atom_id2_dim -1] + (a2 - starts2[coeff_in_2])
        newline = str(a1_mod) + " " + str(a2_mod) + " " + coeff
        twoBodyDynOut.append(newline)

    #Write empty lines in full Jastrow

    if is_full:
        starts_partial_1 = starts[np.array(atom_indices1) -1]
        starts_partial_2 = starts[np.array(atom_indices2) -1]
        ends_partial_1 = ends[np.array(atom_indices1) -1]
        ends_partial_2 = ends[np.array(atom_indices2) -1]


        a1_idxs = []
        a2_idxs = []
        for k in range(len(starts_partial_1)):
            a1_idxs.append(np.arange(starts_partial_1[k], ends_partial_1[k] + 1))
        for k in range(len(starts_partial_2)):
            a2_idxs.append(np.arange(starts_partial_2[k], ends_partial_2[k] + 1))

        a1_idxs = np.concatenate(a1_idxs)
        a2_idxs = np.concatenate(a2_idxs)
        p1 = product(a1_idxs.tolist(), a2_idxs.tolist())
        for idxs in p1:
            a1 = idxs[0]
            a2 = idxs[1]
            newline1 = str(a1) + " " + str(a2) + " 0.00000000E+01"*coeff_len
            newline2 = str(a2) + " " + str(a1) + " 0.00000000E+01"*coeff_len
            twoBodyDynOut.append(newline1)
            twoBodyDynOut.append(newline2)

    #Sort lines for clarity
    twoBodyDynOut[sidx:] = sorted(twoBodyDynOut[sidx:],
            key=lambda s:(int(s.split()[0]), int(s.split()[1])))

    twoBodyDynOut[1] = " ".join(twoBodyDynOut[1].split()[1:])
    if jtype == 'm' or jtype == 'c':
        twoBodyDynOut[1] = str(len(twoBodyDynOut[2:])) + " " + twoBodyDynOut[1]
    elif jtype == 's':
        twoBodyDynOut[1] = str(len(twoBodyDynOut[2:])-1) + " " + twoBodyDynOut[1]


def replaceOneBodyCusp(
    oneBodyCuspIn: list, oneBodyCuspOut: list, atom_indices: list
):
    oneBodyCuspOut.append(oneBodyCuspIn[0])
    oneBodyCuspOut.append(oneBodyCuspIn[1])
    for a_idx in atom_indices:
        for i in range(3):
            oneBodyCuspOut.append(oneBodyCuspIn[2 + i + (a_idx - 1) * 3])
    oneBodyCuspOut.append(oneBodyCuspIn[-1])
    oneBodyCuspOut[1] = oneBodyCuspOut[1].split()
    oneBodyCuspOut[1].pop(2)
    oneBodyCuspOut[1].insert(2, str(len(atom_indices)))
    oneBodyCuspOut[1] = " ".join(oneBodyCuspOut[1])

if __name__ == "__main__":
    args = p.parse_args()

    paramFileName = args.param
    xyzFileName   = args.xyz

    idx_1 = set(args.id1)
    idx_2 = set(args.id2)
    if idx_1.intersection(idx_2) != set():
        print('Error: Dimers not clearly defined, overlapping indices.')
        sys.exit(1)
    idx_1 = sorted(idx_1)
    idx_2 = sorted(idx_2)

    name_jastFileIn   = args.jstFileIn
    name_jastFileOut1 = args.jstFileOut1
    name_jastFileOut2 = args.jstFileOut2

    jasType = args.jtype[0]
    jasForm = args.jtype[1]

    # --- always prepare atom types and jast sizes ---
    atom_types, _ = readXyzFile(xyzFileName)
    jastSizes  = [0] * len(atom_types)
    readParamFile(paramFileName, jastSizes, atom_types)

    # --- read input/output jastrows ---
    twoBodyDynIn, twoBodyCuspIn = [], []
    oneBodyCuspIn = []
    oneBodyCuspOut1, oneBodyCuspOut2 = [], []
    twoBodyDynOut1, twoBodyDynOut2 = [], []
    oneBodyDynIn = []
    oneBodyDynD1, oneBodyDynD2 = [], []

    readJastFact(name_jastFileIn,  twoBodyDyn=twoBodyDynIn, twoBodyCusp=twoBodyCuspIn,
                 oneBodyCusp=oneBodyCuspIn, oneBodyDyn=oneBodyDynIn)
    readJastFact(name_jastFileOut1, oneBodyDyn=oneBodyDynD1, twoBodyDyn=twoBodyDynOut1,
                 oneBodyCusp=oneBodyCuspOut1)
    readJastFact(name_jastFileOut2, oneBodyDyn=oneBodyDynD2, twoBodyDyn=twoBodyDynOut2,
                 oneBodyCusp=oneBodyCuspOut2)

    # --- jd2 replacement ---
    if args.jd2:
        if args.reverse2b:
            twoBodyDynIn = []
            is_full = (jasForm == 'f')
            replaceDynJast_inverse(twoBodyDynOut1, twoBodyDynOut2, twoBodyDynIn,
                                   jastSizes, idx_1, idx_2, jasType, is_full)
        else:
            twoBodyDynOut1, twoBodyDynOut2 = [], []
            replaceDynJast(twoBodyDynIn, twoBodyDynOut1, jastSizes, idx_1, jasType)
            replaceDynJast(twoBodyDynIn, twoBodyDynOut2, jastSizes, idx_2, jasType)

    # --- jc1 replacement ---
    if args.jc1:
        oneBodyCuspOut1, oneBodyCuspOut2 = [], []
        replaceOneBodyCusp(oneBodyCuspIn, oneBodyCuspOut1, idx_1)
        replaceOneBodyCusp(oneBodyCuspIn, oneBodyCuspOut2, idx_2)

    # --- write jst.sav files ---
    if not args.reverse2b:
        writeJastFact(name_jastFileOut1, oneBodyCuspOut1, twoBodyCuspIn, oneBodyDynD1, twoBodyDynOut1)
        writeJastFact(name_jastFileOut2, oneBodyCuspOut2, twoBodyCuspIn, oneBodyDynD2, twoBodyDynOut2)
    else:
        writeJastFact(name_jastFileIn, oneBodyCuspIn, twoBodyCuspIn, oneBodyDynIn, twoBodyDynIn)

    # --- basis set files only if requested ---
    if args.jbas and not args.reverse2b:
        name_jastBasIn, name_jastBasOut1, name_jastBasOut2 = args.jbas
        jastBasisIn = []
        readJastBas(name_jastBasIn, jastBasisIn)
        writeJastBas(name_jastBasOut1, jastBasisIn, idx_1)
        writeJastBas(name_jastBasOut2, jastBasisIn, idx_2)
